// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"github.com/aws-contrib/aurora/internal/database/ent"
)

type FakeGateway struct {
	ApplyRevisionStub        func(context.Context, *ent.ApplyRevisionParams) error
	applyRevisionMutex       sync.RWMutex
	applyRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ApplyRevisionParams
	}
	applyRevisionReturns struct {
		result1 error
	}
	applyRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CreateTableRevisionsStub        func(context.Context) error
	createTableRevisionsMutex       sync.RWMutex
	createTableRevisionsArgsForCall []struct {
		arg1 context.Context
	}
	createTableRevisionsReturns struct {
		result1 error
	}
	createTableRevisionsReturnsOnCall map[int]struct {
		result1 error
	}
	ExecInsertRevisionStub        func(context.Context, *ent.ExecInsertRevisionParams) error
	execInsertRevisionMutex       sync.RWMutex
	execInsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}
	execInsertRevisionReturns struct {
		result1 error
	}
	execInsertRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	GetRevisionStub        func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)
	getRevisionMutex       sync.RWMutex
	getRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}
	getRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	getRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	InsertRevisionStub        func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)
	insertRevisionMutex       sync.RWMutex
	insertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}
	insertRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	insertRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	ListRevisionsStub        func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)
	listRevisionsMutex       sync.RWMutex
	listRevisionsArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}
	listRevisionsReturns struct {
		result1 []*ent.Revision
		result2 error
	}
	listRevisionsReturnsOnCall map[int]struct {
		result1 []*ent.Revision
		result2 error
	}
	PingStub        func(context.Context) error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 context.Context
	}
	pingReturns struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	RunInTxStub        func(context.Context, ent.QuerierAction) error
	runInTxMutex       sync.RWMutex
	runInTxArgsForCall []struct {
		arg1 context.Context
		arg2 ent.QuerierAction
	}
	runInTxReturns struct {
		result1 error
	}
	runInTxReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForJobStub        func(context.Context, *ent.WaitForJobParams) (bool, error)
	waitForJobMutex       sync.RWMutex
	waitForJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.WaitForJobParams
	}
	waitForJobReturns struct {
		result1 bool
		result2 error
	}
	waitForJobReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGateway) ApplyRevision(arg1 context.Context, arg2 *ent.ApplyRevisionParams) error {
	fake.applyRevisionMutex.Lock()
	ret, specificReturn := fake.applyRevisionReturnsOnCall[len(fake.applyRevisionArgsForCall)]
	fake.applyRevisionArgsForCall = append(fake.applyRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ApplyRevisionParams
	}{arg1, arg2})
	stub := fake.ApplyRevisionStub
	fakeReturns := fake.applyRevisionReturns
	fake.recordInvocation("ApplyRevision", []interface{}{arg1, arg2})
	fake.applyRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ApplyRevisionCallCount() int {
	fake.applyRevisionMutex.RLock()
	defer fake.applyRevisionMutex.RUnlock()
	return len(fake.applyRevisionArgsForCall)
}

func (fake *FakeGateway) ApplyRevisionCalls(stub func(context.Context, *ent.ApplyRevisionParams) error) {
	fake.applyRevisionMutex.Lock()
	defer fake.applyRevisionMutex.Unlock()
	fake.ApplyRevisionStub = stub
}

func (fake *FakeGateway) ApplyRevisionArgsForCall(i int) (context.Context, *ent.ApplyRevisionParams) {
	fake.applyRevisionMutex.RLock()
	defer fake.applyRevisionMutex.RUnlock()
	argsForCall := fake.applyRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ApplyRevisionReturns(result1 error) {
	fake.applyRevisionMutex.Lock()
	defer fake.applyRevisionMutex.Unlock()
	fake.ApplyRevisionStub = nil
	fake.applyRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ApplyRevisionReturnsOnCall(i int, result1 error) {
	fake.applyRevisionMutex.Lock()
	defer fake.applyRevisionMutex.Unlock()
	fake.ApplyRevisionStub = nil
	if fake.applyRevisionReturnsOnCall == nil {
		fake.applyRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeGateway) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeGateway) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeGateway) CreateTableRevisions(arg1 context.Context) error {
	fake.createTableRevisionsMutex.Lock()
	ret, specificReturn := fake.createTableRevisionsReturnsOnCall[len(fake.createTableRevisionsArgsForCall)]
	fake.createTableRevisionsArgsForCall = append(fake.createTableRevisionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateTableRevisionsStub
	fakeReturns := fake.createTableRevisionsReturns
	fake.recordInvocation("CreateTableRevisions", []interface{}{arg1})
	fake.createTableRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) CreateTableRevisionsCallCount() int {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	return len(fake.createTableRevisionsArgsForCall)
}

func (fake *FakeGateway) CreateTableRevisionsCalls(stub func(context.Context) error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = stub
}

func (fake *FakeGateway) CreateTableRevisionsArgsForCall(i int) context.Context {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	argsForCall := fake.createTableRevisionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGateway) CreateTableRevisionsReturns(result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	fake.createTableRevisionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateTableRevisionsReturnsOnCall(i int, result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	if fake.createTableRevisionsReturnsOnCall == nil {
		fake.createTableRevisionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableRevisionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertRevision(arg1 context.Context, arg2 *ent.ExecInsertRevisionParams) error {
	fake.execInsertRevisionMutex.Lock()
	ret, specificReturn := fake.execInsertRevisionReturnsOnCall[len(fake.execInsertRevisionArgsForCall)]
	fake.execInsertRevisionArgsForCall = append(fake.execInsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}{arg1, arg2})
	stub := fake.ExecInsertRevisionStub
	fakeReturns := fake.execInsertRevisionReturns
	fake.recordInvocation("ExecInsertRevision", []interface{}{arg1, arg2})
	fake.execInsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecInsertRevisionCallCount() int {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	return len(fake.execInsertRevisionArgsForCall)
}

func (fake *FakeGateway) ExecInsertRevisionCalls(stub func(context.Context, *ent.ExecInsertRevisionParams) error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = stub
}

func (fake *FakeGateway) ExecInsertRevisionArgsForCall(i int) (context.Context, *ent.ExecInsertRevisionParams) {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	argsForCall := fake.execInsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecInsertRevisionReturns(result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	fake.execInsertRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertRevisionReturnsOnCall(i int, result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	if fake.execInsertRevisionReturnsOnCall == nil {
		fake.execInsertRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execInsertRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) GetRevision(arg1 context.Context, arg2 *ent.GetRevisionParams) (*ent.Revision, error) {
	fake.getRevisionMutex.Lock()
	ret, specificReturn := fake.getRevisionReturnsOnCall[len(fake.getRevisionArgsForCall)]
	fake.getRevisionArgsForCall = append(fake.getRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}{arg1, arg2})
	stub := fake.GetRevisionStub
	fakeReturns := fake.getRevisionReturns
	fake.recordInvocation("GetRevision", []interface{}{arg1, arg2})
	fake.getRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) GetRevisionCallCount() int {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	return len(fake.getRevisionArgsForCall)
}

func (fake *FakeGateway) GetRevisionCalls(stub func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = stub
}

func (fake *FakeGateway) GetRevisionArgsForCall(i int) (context.Context, *ent.GetRevisionParams) {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	argsForCall := fake.getRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) GetRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	fake.getRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) GetRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	if fake.getRevisionReturnsOnCall == nil {
		fake.getRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.getRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertRevision(arg1 context.Context, arg2 *ent.InsertRevisionParams) (*ent.Revision, error) {
	fake.insertRevisionMutex.Lock()
	ret, specificReturn := fake.insertRevisionReturnsOnCall[len(fake.insertRevisionArgsForCall)]
	fake.insertRevisionArgsForCall = append(fake.insertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}{arg1, arg2})
	stub := fake.InsertRevisionStub
	fakeReturns := fake.insertRevisionReturns
	fake.recordInvocation("InsertRevision", []interface{}{arg1, arg2})
	fake.insertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) InsertRevisionCallCount() int {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	return len(fake.insertRevisionArgsForCall)
}

func (fake *FakeGateway) InsertRevisionCalls(stub func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = stub
}

func (fake *FakeGateway) InsertRevisionArgsForCall(i int) (context.Context, *ent.InsertRevisionParams) {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	argsForCall := fake.insertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) InsertRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	fake.insertRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	if fake.insertRevisionReturnsOnCall == nil {
		fake.insertRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.insertRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) ListRevisions(arg1 context.Context, arg2 *ent.ListRevisionsParams) ([]*ent.Revision, error) {
	fake.listRevisionsMutex.Lock()
	ret, specificReturn := fake.listRevisionsReturnsOnCall[len(fake.listRevisionsArgsForCall)]
	fake.listRevisionsArgsForCall = append(fake.listRevisionsArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}{arg1, arg2})
	stub := fake.ListRevisionsStub
	fakeReturns := fake.listRevisionsReturns
	fake.recordInvocation("ListRevisions", []interface{}{arg1, arg2})
	fake.listRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) ListRevisionsCallCount() int {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	return len(fake.listRevisionsArgsForCall)
}

func (fake *FakeGateway) ListRevisionsCalls(stub func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = stub
}

func (fake *FakeGateway) ListRevisionsArgsForCall(i int) (context.Context, *ent.ListRevisionsParams) {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	argsForCall := fake.listRevisionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ListRevisionsReturns(result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	fake.listRevisionsReturns = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) ListRevisionsReturnsOnCall(i int, result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	if fake.listRevisionsReturnsOnCall == nil {
		fake.listRevisionsReturnsOnCall = make(map[int]struct {
			result1 []*ent.Revision
			result2 error
		})
	}
	fake.listRevisionsReturnsOnCall[i] = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) Ping(arg1 context.Context) error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PingStub
	fakeReturns := fake.pingReturns
	fake.recordInvocation("Ping", []interface{}{arg1})
	fake.pingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeGateway) PingCalls(stub func(context.Context) error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeGateway) PingArgsForCall(i int) context.Context {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGateway) PingReturns(result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) PingReturnsOnCall(i int, result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) RunInTx(arg1 context.Context, arg2 ent.QuerierAction) error {
	fake.runInTxMutex.Lock()
	ret, specificReturn := fake.runInTxReturnsOnCall[len(fake.runInTxArgsForCall)]
	fake.runInTxArgsForCall = append(fake.runInTxArgsForCall, struct {
		arg1 context.Context
		arg2 ent.QuerierAction
	}{arg1, arg2})
	stub := fake.RunInTxStub
	fakeReturns := fake.runInTxReturns
	fake.recordInvocation("RunInTx", []interface{}{arg1, arg2})
	fake.runInTxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) RunInTxCallCount() int {
	fake.runInTxMutex.RLock()
	defer fake.runInTxMutex.RUnlock()
	return len(fake.runInTxArgsForCall)
}

func (fake *FakeGateway) RunInTxCalls(stub func(context.Context, ent.QuerierAction) error) {
	fake.runInTxMutex.Lock()
	defer fake.runInTxMutex.Unlock()
	fake.RunInTxStub = stub
}

func (fake *FakeGateway) RunInTxArgsForCall(i int) (context.Context, ent.QuerierAction) {
	fake.runInTxMutex.RLock()
	defer fake.runInTxMutex.RUnlock()
	argsForCall := fake.runInTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) RunInTxReturns(result1 error) {
	fake.runInTxMutex.Lock()
	defer fake.runInTxMutex.Unlock()
	fake.RunInTxStub = nil
	fake.runInTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) RunInTxReturnsOnCall(i int, result1 error) {
	fake.runInTxMutex.Lock()
	defer fake.runInTxMutex.Unlock()
	fake.RunInTxStub = nil
	if fake.runInTxReturnsOnCall == nil {
		fake.runInTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runInTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) WaitForJob(arg1 context.Context, arg2 *ent.WaitForJobParams) (bool, error) {
	fake.waitForJobMutex.Lock()
	ret, specificReturn := fake.waitForJobReturnsOnCall[len(fake.waitForJobArgsForCall)]
	fake.waitForJobArgsForCall = append(fake.waitForJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.WaitForJobParams
	}{arg1, arg2})
	stub := fake.WaitForJobStub
	fakeReturns := fake.waitForJobReturns
	fake.recordInvocation("WaitForJob", []interface{}{arg1, arg2})
	fake.waitForJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) WaitForJobCallCount() int {
	fake.waitForJobMutex.RLock()
	defer fake.waitForJobMutex.RUnlock()
	return len(fake.waitForJobArgsForCall)
}

func (fake *FakeGateway) WaitForJobCalls(stub func(context.Context, *ent.WaitForJobParams) (bool, error)) {
	fake.waitForJobMutex.Lock()
	defer fake.waitForJobMutex.Unlock()
	fake.WaitForJobStub = stub
}

func (fake *FakeGateway) WaitForJobArgsForCall(i int) (context.Context, *ent.WaitForJobParams) {
	fake.waitForJobMutex.RLock()
	defer fake.waitForJobMutex.RUnlock()
	argsForCall := fake.waitForJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) WaitForJobReturns(result1 bool, result2 error) {
	fake.waitForJobMutex.Lock()
	defer fake.waitForJobMutex.Unlock()
	fake.WaitForJobStub = nil
	fake.waitForJobReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) WaitForJobReturnsOnCall(i int, result1 bool, result2 error) {
	fake.waitForJobMutex.Lock()
	defer fake.waitForJobMutex.Unlock()
	fake.WaitForJobStub = nil
	if fake.waitForJobReturnsOnCall == nil {
		fake.waitForJobReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.waitForJobReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGateway) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ent.Gateway = new(FakeGateway)
