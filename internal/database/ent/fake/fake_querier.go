// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"github.com/aws-contrib/aurora/internal/database/ent"
)

type FakeQuerier struct {
	CreateTableRevisionsStub        func(context.Context) error
	createTableRevisionsMutex       sync.RWMutex
	createTableRevisionsArgsForCall []struct {
		arg1 context.Context
	}
	createTableRevisionsReturns struct {
		result1 error
	}
	createTableRevisionsReturnsOnCall map[int]struct {
		result1 error
	}
	ExecInsertRevisionStub        func(context.Context, *ent.ExecInsertRevisionParams) error
	execInsertRevisionMutex       sync.RWMutex
	execInsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}
	execInsertRevisionReturns struct {
		result1 error
	}
	execInsertRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	GetRevisionStub        func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)
	getRevisionMutex       sync.RWMutex
	getRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}
	getRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	getRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	InsertRevisionStub        func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)
	insertRevisionMutex       sync.RWMutex
	insertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}
	insertRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	insertRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	ListRevisionsStub        func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)
	listRevisionsMutex       sync.RWMutex
	listRevisionsArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}
	listRevisionsReturns struct {
		result1 []*ent.Revision
		result2 error
	}
	listRevisionsReturnsOnCall map[int]struct {
		result1 []*ent.Revision
		result2 error
	}
	WaitForJobStub        func(context.Context, *ent.WaitForJobParams) (bool, error)
	waitForJobMutex       sync.RWMutex
	waitForJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.WaitForJobParams
	}
	waitForJobReturns struct {
		result1 bool
		result2 error
	}
	waitForJobReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQuerier) CreateTableRevisions(arg1 context.Context) error {
	fake.createTableRevisionsMutex.Lock()
	ret, specificReturn := fake.createTableRevisionsReturnsOnCall[len(fake.createTableRevisionsArgsForCall)]
	fake.createTableRevisionsArgsForCall = append(fake.createTableRevisionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateTableRevisionsStub
	fakeReturns := fake.createTableRevisionsReturns
	fake.recordInvocation("CreateTableRevisions", []interface{}{arg1})
	fake.createTableRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) CreateTableRevisionsCallCount() int {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	return len(fake.createTableRevisionsArgsForCall)
}

func (fake *FakeQuerier) CreateTableRevisionsCalls(stub func(context.Context) error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = stub
}

func (fake *FakeQuerier) CreateTableRevisionsArgsForCall(i int) context.Context {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	argsForCall := fake.createTableRevisionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuerier) CreateTableRevisionsReturns(result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	fake.createTableRevisionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) CreateTableRevisionsReturnsOnCall(i int, result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	if fake.createTableRevisionsReturnsOnCall == nil {
		fake.createTableRevisionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableRevisionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecInsertRevision(arg1 context.Context, arg2 *ent.ExecInsertRevisionParams) error {
	fake.execInsertRevisionMutex.Lock()
	ret, specificReturn := fake.execInsertRevisionReturnsOnCall[len(fake.execInsertRevisionArgsForCall)]
	fake.execInsertRevisionArgsForCall = append(fake.execInsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}{arg1, arg2})
	stub := fake.ExecInsertRevisionStub
	fakeReturns := fake.execInsertRevisionReturns
	fake.recordInvocation("ExecInsertRevision", []interface{}{arg1, arg2})
	fake.execInsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecInsertRevisionCallCount() int {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	return len(fake.execInsertRevisionArgsForCall)
}

func (fake *FakeQuerier) ExecInsertRevisionCalls(stub func(context.Context, *ent.ExecInsertRevisionParams) error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = stub
}

func (fake *FakeQuerier) ExecInsertRevisionArgsForCall(i int) (context.Context, *ent.ExecInsertRevisionParams) {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	argsForCall := fake.execInsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecInsertRevisionReturns(result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	fake.execInsertRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecInsertRevisionReturnsOnCall(i int, result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	if fake.execInsertRevisionReturnsOnCall == nil {
		fake.execInsertRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execInsertRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) GetRevision(arg1 context.Context, arg2 *ent.GetRevisionParams) (*ent.Revision, error) {
	fake.getRevisionMutex.Lock()
	ret, specificReturn := fake.getRevisionReturnsOnCall[len(fake.getRevisionArgsForCall)]
	fake.getRevisionArgsForCall = append(fake.getRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}{arg1, arg2})
	stub := fake.GetRevisionStub
	fakeReturns := fake.getRevisionReturns
	fake.recordInvocation("GetRevision", []interface{}{arg1, arg2})
	fake.getRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) GetRevisionCallCount() int {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	return len(fake.getRevisionArgsForCall)
}

func (fake *FakeQuerier) GetRevisionCalls(stub func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = stub
}

func (fake *FakeQuerier) GetRevisionArgsForCall(i int) (context.Context, *ent.GetRevisionParams) {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	argsForCall := fake.getRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) GetRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	fake.getRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) GetRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	if fake.getRevisionReturnsOnCall == nil {
		fake.getRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.getRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) InsertRevision(arg1 context.Context, arg2 *ent.InsertRevisionParams) (*ent.Revision, error) {
	fake.insertRevisionMutex.Lock()
	ret, specificReturn := fake.insertRevisionReturnsOnCall[len(fake.insertRevisionArgsForCall)]
	fake.insertRevisionArgsForCall = append(fake.insertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}{arg1, arg2})
	stub := fake.InsertRevisionStub
	fakeReturns := fake.insertRevisionReturns
	fake.recordInvocation("InsertRevision", []interface{}{arg1, arg2})
	fake.insertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) InsertRevisionCallCount() int {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	return len(fake.insertRevisionArgsForCall)
}

func (fake *FakeQuerier) InsertRevisionCalls(stub func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = stub
}

func (fake *FakeQuerier) InsertRevisionArgsForCall(i int) (context.Context, *ent.InsertRevisionParams) {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	argsForCall := fake.insertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) InsertRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	fake.insertRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) InsertRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	if fake.insertRevisionReturnsOnCall == nil {
		fake.insertRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.insertRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ListRevisions(arg1 context.Context, arg2 *ent.ListRevisionsParams) ([]*ent.Revision, error) {
	fake.listRevisionsMutex.Lock()
	ret, specificReturn := fake.listRevisionsReturnsOnCall[len(fake.listRevisionsArgsForCall)]
	fake.listRevisionsArgsForCall = append(fake.listRevisionsArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}{arg1, arg2})
	stub := fake.ListRevisionsStub
	fakeReturns := fake.listRevisionsReturns
	fake.recordInvocation("ListRevisions", []interface{}{arg1, arg2})
	fake.listRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ListRevisionsCallCount() int {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	return len(fake.listRevisionsArgsForCall)
}

func (fake *FakeQuerier) ListRevisionsCalls(stub func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = stub
}

func (fake *FakeQuerier) ListRevisionsArgsForCall(i int) (context.Context, *ent.ListRevisionsParams) {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	argsForCall := fake.listRevisionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ListRevisionsReturns(result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	fake.listRevisionsReturns = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ListRevisionsReturnsOnCall(i int, result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	if fake.listRevisionsReturnsOnCall == nil {
		fake.listRevisionsReturnsOnCall = make(map[int]struct {
			result1 []*ent.Revision
			result2 error
		})
	}
	fake.listRevisionsReturnsOnCall[i] = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) WaitForJob(arg1 context.Context, arg2 *ent.WaitForJobParams) (bool, error) {
	fake.waitForJobMutex.Lock()
	ret, specificReturn := fake.waitForJobReturnsOnCall[len(fake.waitForJobArgsForCall)]
	fake.waitForJobArgsForCall = append(fake.waitForJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.WaitForJobParams
	}{arg1, arg2})
	stub := fake.WaitForJobStub
	fakeReturns := fake.waitForJobReturns
	fake.recordInvocation("WaitForJob", []interface{}{arg1, arg2})
	fake.waitForJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) WaitForJobCallCount() int {
	fake.waitForJobMutex.RLock()
	defer fake.waitForJobMutex.RUnlock()
	return len(fake.waitForJobArgsForCall)
}

func (fake *FakeQuerier) WaitForJobCalls(stub func(context.Context, *ent.WaitForJobParams) (bool, error)) {
	fake.waitForJobMutex.Lock()
	defer fake.waitForJobMutex.Unlock()
	fake.WaitForJobStub = stub
}

func (fake *FakeQuerier) WaitForJobArgsForCall(i int) (context.Context, *ent.WaitForJobParams) {
	fake.waitForJobMutex.RLock()
	defer fake.waitForJobMutex.RUnlock()
	argsForCall := fake.waitForJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) WaitForJobReturns(result1 bool, result2 error) {
	fake.waitForJobMutex.Lock()
	defer fake.waitForJobMutex.Unlock()
	fake.WaitForJobStub = nil
	fake.waitForJobReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) WaitForJobReturnsOnCall(i int, result1 bool, result2 error) {
	fake.waitForJobMutex.Lock()
	defer fake.waitForJobMutex.Unlock()
	fake.WaitForJobStub = nil
	if fake.waitForJobReturnsOnCall == nil {
		fake.waitForJobReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.waitForJobReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQuerier) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ent.Querier = new(FakeQuerier)
