// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"github.com/aws-contrib/aurora/internal/database/ent"
)

type FakeQuerier struct {
	CreateSchemaSysStub        func(context.Context) error
	createSchemaSysMutex       sync.RWMutex
	createSchemaSysArgsForCall []struct {
		arg1 context.Context
	}
	createSchemaSysReturns struct {
		result1 error
	}
	createSchemaSysReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTableJobsStub        func(context.Context) error
	createTableJobsMutex       sync.RWMutex
	createTableJobsArgsForCall []struct {
		arg1 context.Context
	}
	createTableJobsReturns struct {
		result1 error
	}
	createTableJobsReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTableRevisionsStub        func(context.Context) error
	createTableRevisionsMutex       sync.RWMutex
	createTableRevisionsArgsForCall []struct {
		arg1 context.Context
	}
	createTableRevisionsReturns struct {
		result1 error
	}
	createTableRevisionsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteJobStub        func(context.Context, *ent.DeleteJobParams) (*ent.Job, error)
	deleteJobMutex       sync.RWMutex
	deleteJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.DeleteJobParams
	}
	deleteJobReturns struct {
		result1 *ent.Job
		result2 error
	}
	deleteJobReturnsOnCall map[int]struct {
		result1 *ent.Job
		result2 error
	}
	DeleteRevisionStub        func(context.Context, *ent.DeleteRevisionParams) (*ent.Revision, error)
	deleteRevisionMutex       sync.RWMutex
	deleteRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.DeleteRevisionParams
	}
	deleteRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	deleteRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	ExecDeleteJobStub        func(context.Context, *ent.ExecDeleteJobParams) error
	execDeleteJobMutex       sync.RWMutex
	execDeleteJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteJobParams
	}
	execDeleteJobReturns struct {
		result1 error
	}
	execDeleteJobReturnsOnCall map[int]struct {
		result1 error
	}
	ExecDeleteRevisionStub        func(context.Context, *ent.ExecDeleteRevisionParams) error
	execDeleteRevisionMutex       sync.RWMutex
	execDeleteRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteRevisionParams
	}
	execDeleteRevisionReturns struct {
		result1 error
	}
	execDeleteRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	ExecInsertJobStub        func(context.Context, *ent.ExecInsertJobParams) error
	execInsertJobMutex       sync.RWMutex
	execInsertJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecInsertJobParams
	}
	execInsertJobReturns struct {
		result1 error
	}
	execInsertJobReturnsOnCall map[int]struct {
		result1 error
	}
	ExecInsertRevisionStub        func(context.Context, *ent.ExecInsertRevisionParams) error
	execInsertRevisionMutex       sync.RWMutex
	execInsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}
	execInsertRevisionReturns struct {
		result1 error
	}
	execInsertRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	ExecUpdateRevisionStub        func(context.Context, *ent.ExecUpdateRevisionParams) error
	execUpdateRevisionMutex       sync.RWMutex
	execUpdateRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecUpdateRevisionParams
	}
	execUpdateRevisionReturns struct {
		result1 error
	}
	execUpdateRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	ExecUpsertRevisionStub        func(context.Context, *ent.ExecUpsertRevisionParams) error
	execUpsertRevisionMutex       sync.RWMutex
	execUpsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecUpsertRevisionParams
	}
	execUpsertRevisionReturns struct {
		result1 error
	}
	execUpsertRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	GetJobStub        func(context.Context, *ent.GetJobParams) (*ent.Job, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.GetJobParams
	}
	getJobReturns struct {
		result1 *ent.Job
		result2 error
	}
	getJobReturnsOnCall map[int]struct {
		result1 *ent.Job
		result2 error
	}
	GetRevisionStub        func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)
	getRevisionMutex       sync.RWMutex
	getRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}
	getRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	getRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	InsertJobStub        func(context.Context, *ent.InsertJobParams) (*ent.Job, error)
	insertJobMutex       sync.RWMutex
	insertJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.InsertJobParams
	}
	insertJobReturns struct {
		result1 *ent.Job
		result2 error
	}
	insertJobReturnsOnCall map[int]struct {
		result1 *ent.Job
		result2 error
	}
	InsertRevisionStub        func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)
	insertRevisionMutex       sync.RWMutex
	insertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}
	insertRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	insertRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	ListRevisionsStub        func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)
	listRevisionsMutex       sync.RWMutex
	listRevisionsArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}
	listRevisionsReturns struct {
		result1 []*ent.Revision
		result2 error
	}
	listRevisionsReturnsOnCall map[int]struct {
		result1 []*ent.Revision
		result2 error
	}
	UpdateRevisionStub        func(context.Context, *ent.UpdateRevisionParams) (*ent.Revision, error)
	updateRevisionMutex       sync.RWMutex
	updateRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.UpdateRevisionParams
	}
	updateRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	updateRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	UpsertRevisionStub        func(context.Context, *ent.UpsertRevisionParams) (*ent.Revision, error)
	upsertRevisionMutex       sync.RWMutex
	upsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.UpsertRevisionParams
	}
	upsertRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	upsertRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQuerier) CreateSchemaSys(arg1 context.Context) error {
	fake.createSchemaSysMutex.Lock()
	ret, specificReturn := fake.createSchemaSysReturnsOnCall[len(fake.createSchemaSysArgsForCall)]
	fake.createSchemaSysArgsForCall = append(fake.createSchemaSysArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateSchemaSysStub
	fakeReturns := fake.createSchemaSysReturns
	fake.recordInvocation("CreateSchemaSys", []interface{}{arg1})
	fake.createSchemaSysMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) CreateSchemaSysCallCount() int {
	fake.createSchemaSysMutex.RLock()
	defer fake.createSchemaSysMutex.RUnlock()
	return len(fake.createSchemaSysArgsForCall)
}

func (fake *FakeQuerier) CreateSchemaSysCalls(stub func(context.Context) error) {
	fake.createSchemaSysMutex.Lock()
	defer fake.createSchemaSysMutex.Unlock()
	fake.CreateSchemaSysStub = stub
}

func (fake *FakeQuerier) CreateSchemaSysArgsForCall(i int) context.Context {
	fake.createSchemaSysMutex.RLock()
	defer fake.createSchemaSysMutex.RUnlock()
	argsForCall := fake.createSchemaSysArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuerier) CreateSchemaSysReturns(result1 error) {
	fake.createSchemaSysMutex.Lock()
	defer fake.createSchemaSysMutex.Unlock()
	fake.CreateSchemaSysStub = nil
	fake.createSchemaSysReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) CreateSchemaSysReturnsOnCall(i int, result1 error) {
	fake.createSchemaSysMutex.Lock()
	defer fake.createSchemaSysMutex.Unlock()
	fake.CreateSchemaSysStub = nil
	if fake.createSchemaSysReturnsOnCall == nil {
		fake.createSchemaSysReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createSchemaSysReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) CreateTableJobs(arg1 context.Context) error {
	fake.createTableJobsMutex.Lock()
	ret, specificReturn := fake.createTableJobsReturnsOnCall[len(fake.createTableJobsArgsForCall)]
	fake.createTableJobsArgsForCall = append(fake.createTableJobsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateTableJobsStub
	fakeReturns := fake.createTableJobsReturns
	fake.recordInvocation("CreateTableJobs", []interface{}{arg1})
	fake.createTableJobsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) CreateTableJobsCallCount() int {
	fake.createTableJobsMutex.RLock()
	defer fake.createTableJobsMutex.RUnlock()
	return len(fake.createTableJobsArgsForCall)
}

func (fake *FakeQuerier) CreateTableJobsCalls(stub func(context.Context) error) {
	fake.createTableJobsMutex.Lock()
	defer fake.createTableJobsMutex.Unlock()
	fake.CreateTableJobsStub = stub
}

func (fake *FakeQuerier) CreateTableJobsArgsForCall(i int) context.Context {
	fake.createTableJobsMutex.RLock()
	defer fake.createTableJobsMutex.RUnlock()
	argsForCall := fake.createTableJobsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuerier) CreateTableJobsReturns(result1 error) {
	fake.createTableJobsMutex.Lock()
	defer fake.createTableJobsMutex.Unlock()
	fake.CreateTableJobsStub = nil
	fake.createTableJobsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) CreateTableJobsReturnsOnCall(i int, result1 error) {
	fake.createTableJobsMutex.Lock()
	defer fake.createTableJobsMutex.Unlock()
	fake.CreateTableJobsStub = nil
	if fake.createTableJobsReturnsOnCall == nil {
		fake.createTableJobsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableJobsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) CreateTableRevisions(arg1 context.Context) error {
	fake.createTableRevisionsMutex.Lock()
	ret, specificReturn := fake.createTableRevisionsReturnsOnCall[len(fake.createTableRevisionsArgsForCall)]
	fake.createTableRevisionsArgsForCall = append(fake.createTableRevisionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateTableRevisionsStub
	fakeReturns := fake.createTableRevisionsReturns
	fake.recordInvocation("CreateTableRevisions", []interface{}{arg1})
	fake.createTableRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) CreateTableRevisionsCallCount() int {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	return len(fake.createTableRevisionsArgsForCall)
}

func (fake *FakeQuerier) CreateTableRevisionsCalls(stub func(context.Context) error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = stub
}

func (fake *FakeQuerier) CreateTableRevisionsArgsForCall(i int) context.Context {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	argsForCall := fake.createTableRevisionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuerier) CreateTableRevisionsReturns(result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	fake.createTableRevisionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) CreateTableRevisionsReturnsOnCall(i int, result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	if fake.createTableRevisionsReturnsOnCall == nil {
		fake.createTableRevisionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableRevisionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) DeleteJob(arg1 context.Context, arg2 *ent.DeleteJobParams) (*ent.Job, error) {
	fake.deleteJobMutex.Lock()
	ret, specificReturn := fake.deleteJobReturnsOnCall[len(fake.deleteJobArgsForCall)]
	fake.deleteJobArgsForCall = append(fake.deleteJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.DeleteJobParams
	}{arg1, arg2})
	stub := fake.DeleteJobStub
	fakeReturns := fake.deleteJobReturns
	fake.recordInvocation("DeleteJob", []interface{}{arg1, arg2})
	fake.deleteJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) DeleteJobCallCount() int {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	return len(fake.deleteJobArgsForCall)
}

func (fake *FakeQuerier) DeleteJobCalls(stub func(context.Context, *ent.DeleteJobParams) (*ent.Job, error)) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = stub
}

func (fake *FakeQuerier) DeleteJobArgsForCall(i int) (context.Context, *ent.DeleteJobParams) {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	argsForCall := fake.deleteJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) DeleteJobReturns(result1 *ent.Job, result2 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	fake.deleteJobReturns = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) DeleteJobReturnsOnCall(i int, result1 *ent.Job, result2 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	if fake.deleteJobReturnsOnCall == nil {
		fake.deleteJobReturnsOnCall = make(map[int]struct {
			result1 *ent.Job
			result2 error
		})
	}
	fake.deleteJobReturnsOnCall[i] = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) DeleteRevision(arg1 context.Context, arg2 *ent.DeleteRevisionParams) (*ent.Revision, error) {
	fake.deleteRevisionMutex.Lock()
	ret, specificReturn := fake.deleteRevisionReturnsOnCall[len(fake.deleteRevisionArgsForCall)]
	fake.deleteRevisionArgsForCall = append(fake.deleteRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.DeleteRevisionParams
	}{arg1, arg2})
	stub := fake.DeleteRevisionStub
	fakeReturns := fake.deleteRevisionReturns
	fake.recordInvocation("DeleteRevision", []interface{}{arg1, arg2})
	fake.deleteRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) DeleteRevisionCallCount() int {
	fake.deleteRevisionMutex.RLock()
	defer fake.deleteRevisionMutex.RUnlock()
	return len(fake.deleteRevisionArgsForCall)
}

func (fake *FakeQuerier) DeleteRevisionCalls(stub func(context.Context, *ent.DeleteRevisionParams) (*ent.Revision, error)) {
	fake.deleteRevisionMutex.Lock()
	defer fake.deleteRevisionMutex.Unlock()
	fake.DeleteRevisionStub = stub
}

func (fake *FakeQuerier) DeleteRevisionArgsForCall(i int) (context.Context, *ent.DeleteRevisionParams) {
	fake.deleteRevisionMutex.RLock()
	defer fake.deleteRevisionMutex.RUnlock()
	argsForCall := fake.deleteRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) DeleteRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.deleteRevisionMutex.Lock()
	defer fake.deleteRevisionMutex.Unlock()
	fake.DeleteRevisionStub = nil
	fake.deleteRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) DeleteRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.deleteRevisionMutex.Lock()
	defer fake.deleteRevisionMutex.Unlock()
	fake.DeleteRevisionStub = nil
	if fake.deleteRevisionReturnsOnCall == nil {
		fake.deleteRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.deleteRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ExecDeleteJob(arg1 context.Context, arg2 *ent.ExecDeleteJobParams) error {
	fake.execDeleteJobMutex.Lock()
	ret, specificReturn := fake.execDeleteJobReturnsOnCall[len(fake.execDeleteJobArgsForCall)]
	fake.execDeleteJobArgsForCall = append(fake.execDeleteJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteJobParams
	}{arg1, arg2})
	stub := fake.ExecDeleteJobStub
	fakeReturns := fake.execDeleteJobReturns
	fake.recordInvocation("ExecDeleteJob", []interface{}{arg1, arg2})
	fake.execDeleteJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecDeleteJobCallCount() int {
	fake.execDeleteJobMutex.RLock()
	defer fake.execDeleteJobMutex.RUnlock()
	return len(fake.execDeleteJobArgsForCall)
}

func (fake *FakeQuerier) ExecDeleteJobCalls(stub func(context.Context, *ent.ExecDeleteJobParams) error) {
	fake.execDeleteJobMutex.Lock()
	defer fake.execDeleteJobMutex.Unlock()
	fake.ExecDeleteJobStub = stub
}

func (fake *FakeQuerier) ExecDeleteJobArgsForCall(i int) (context.Context, *ent.ExecDeleteJobParams) {
	fake.execDeleteJobMutex.RLock()
	defer fake.execDeleteJobMutex.RUnlock()
	argsForCall := fake.execDeleteJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecDeleteJobReturns(result1 error) {
	fake.execDeleteJobMutex.Lock()
	defer fake.execDeleteJobMutex.Unlock()
	fake.ExecDeleteJobStub = nil
	fake.execDeleteJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecDeleteJobReturnsOnCall(i int, result1 error) {
	fake.execDeleteJobMutex.Lock()
	defer fake.execDeleteJobMutex.Unlock()
	fake.ExecDeleteJobStub = nil
	if fake.execDeleteJobReturnsOnCall == nil {
		fake.execDeleteJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execDeleteJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecDeleteRevision(arg1 context.Context, arg2 *ent.ExecDeleteRevisionParams) error {
	fake.execDeleteRevisionMutex.Lock()
	ret, specificReturn := fake.execDeleteRevisionReturnsOnCall[len(fake.execDeleteRevisionArgsForCall)]
	fake.execDeleteRevisionArgsForCall = append(fake.execDeleteRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteRevisionParams
	}{arg1, arg2})
	stub := fake.ExecDeleteRevisionStub
	fakeReturns := fake.execDeleteRevisionReturns
	fake.recordInvocation("ExecDeleteRevision", []interface{}{arg1, arg2})
	fake.execDeleteRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecDeleteRevisionCallCount() int {
	fake.execDeleteRevisionMutex.RLock()
	defer fake.execDeleteRevisionMutex.RUnlock()
	return len(fake.execDeleteRevisionArgsForCall)
}

func (fake *FakeQuerier) ExecDeleteRevisionCalls(stub func(context.Context, *ent.ExecDeleteRevisionParams) error) {
	fake.execDeleteRevisionMutex.Lock()
	defer fake.execDeleteRevisionMutex.Unlock()
	fake.ExecDeleteRevisionStub = stub
}

func (fake *FakeQuerier) ExecDeleteRevisionArgsForCall(i int) (context.Context, *ent.ExecDeleteRevisionParams) {
	fake.execDeleteRevisionMutex.RLock()
	defer fake.execDeleteRevisionMutex.RUnlock()
	argsForCall := fake.execDeleteRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecDeleteRevisionReturns(result1 error) {
	fake.execDeleteRevisionMutex.Lock()
	defer fake.execDeleteRevisionMutex.Unlock()
	fake.ExecDeleteRevisionStub = nil
	fake.execDeleteRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecDeleteRevisionReturnsOnCall(i int, result1 error) {
	fake.execDeleteRevisionMutex.Lock()
	defer fake.execDeleteRevisionMutex.Unlock()
	fake.ExecDeleteRevisionStub = nil
	if fake.execDeleteRevisionReturnsOnCall == nil {
		fake.execDeleteRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execDeleteRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecInsertJob(arg1 context.Context, arg2 *ent.ExecInsertJobParams) error {
	fake.execInsertJobMutex.Lock()
	ret, specificReturn := fake.execInsertJobReturnsOnCall[len(fake.execInsertJobArgsForCall)]
	fake.execInsertJobArgsForCall = append(fake.execInsertJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecInsertJobParams
	}{arg1, arg2})
	stub := fake.ExecInsertJobStub
	fakeReturns := fake.execInsertJobReturns
	fake.recordInvocation("ExecInsertJob", []interface{}{arg1, arg2})
	fake.execInsertJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecInsertJobCallCount() int {
	fake.execInsertJobMutex.RLock()
	defer fake.execInsertJobMutex.RUnlock()
	return len(fake.execInsertJobArgsForCall)
}

func (fake *FakeQuerier) ExecInsertJobCalls(stub func(context.Context, *ent.ExecInsertJobParams) error) {
	fake.execInsertJobMutex.Lock()
	defer fake.execInsertJobMutex.Unlock()
	fake.ExecInsertJobStub = stub
}

func (fake *FakeQuerier) ExecInsertJobArgsForCall(i int) (context.Context, *ent.ExecInsertJobParams) {
	fake.execInsertJobMutex.RLock()
	defer fake.execInsertJobMutex.RUnlock()
	argsForCall := fake.execInsertJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecInsertJobReturns(result1 error) {
	fake.execInsertJobMutex.Lock()
	defer fake.execInsertJobMutex.Unlock()
	fake.ExecInsertJobStub = nil
	fake.execInsertJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecInsertJobReturnsOnCall(i int, result1 error) {
	fake.execInsertJobMutex.Lock()
	defer fake.execInsertJobMutex.Unlock()
	fake.ExecInsertJobStub = nil
	if fake.execInsertJobReturnsOnCall == nil {
		fake.execInsertJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execInsertJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecInsertRevision(arg1 context.Context, arg2 *ent.ExecInsertRevisionParams) error {
	fake.execInsertRevisionMutex.Lock()
	ret, specificReturn := fake.execInsertRevisionReturnsOnCall[len(fake.execInsertRevisionArgsForCall)]
	fake.execInsertRevisionArgsForCall = append(fake.execInsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}{arg1, arg2})
	stub := fake.ExecInsertRevisionStub
	fakeReturns := fake.execInsertRevisionReturns
	fake.recordInvocation("ExecInsertRevision", []interface{}{arg1, arg2})
	fake.execInsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecInsertRevisionCallCount() int {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	return len(fake.execInsertRevisionArgsForCall)
}

func (fake *FakeQuerier) ExecInsertRevisionCalls(stub func(context.Context, *ent.ExecInsertRevisionParams) error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = stub
}

func (fake *FakeQuerier) ExecInsertRevisionArgsForCall(i int) (context.Context, *ent.ExecInsertRevisionParams) {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	argsForCall := fake.execInsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecInsertRevisionReturns(result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	fake.execInsertRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecInsertRevisionReturnsOnCall(i int, result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	if fake.execInsertRevisionReturnsOnCall == nil {
		fake.execInsertRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execInsertRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpdateRevision(arg1 context.Context, arg2 *ent.ExecUpdateRevisionParams) error {
	fake.execUpdateRevisionMutex.Lock()
	ret, specificReturn := fake.execUpdateRevisionReturnsOnCall[len(fake.execUpdateRevisionArgsForCall)]
	fake.execUpdateRevisionArgsForCall = append(fake.execUpdateRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecUpdateRevisionParams
	}{arg1, arg2})
	stub := fake.ExecUpdateRevisionStub
	fakeReturns := fake.execUpdateRevisionReturns
	fake.recordInvocation("ExecUpdateRevision", []interface{}{arg1, arg2})
	fake.execUpdateRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecUpdateRevisionCallCount() int {
	fake.execUpdateRevisionMutex.RLock()
	defer fake.execUpdateRevisionMutex.RUnlock()
	return len(fake.execUpdateRevisionArgsForCall)
}

func (fake *FakeQuerier) ExecUpdateRevisionCalls(stub func(context.Context, *ent.ExecUpdateRevisionParams) error) {
	fake.execUpdateRevisionMutex.Lock()
	defer fake.execUpdateRevisionMutex.Unlock()
	fake.ExecUpdateRevisionStub = stub
}

func (fake *FakeQuerier) ExecUpdateRevisionArgsForCall(i int) (context.Context, *ent.ExecUpdateRevisionParams) {
	fake.execUpdateRevisionMutex.RLock()
	defer fake.execUpdateRevisionMutex.RUnlock()
	argsForCall := fake.execUpdateRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecUpdateRevisionReturns(result1 error) {
	fake.execUpdateRevisionMutex.Lock()
	defer fake.execUpdateRevisionMutex.Unlock()
	fake.ExecUpdateRevisionStub = nil
	fake.execUpdateRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpdateRevisionReturnsOnCall(i int, result1 error) {
	fake.execUpdateRevisionMutex.Lock()
	defer fake.execUpdateRevisionMutex.Unlock()
	fake.ExecUpdateRevisionStub = nil
	if fake.execUpdateRevisionReturnsOnCall == nil {
		fake.execUpdateRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execUpdateRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpsertRevision(arg1 context.Context, arg2 *ent.ExecUpsertRevisionParams) error {
	fake.execUpsertRevisionMutex.Lock()
	ret, specificReturn := fake.execUpsertRevisionReturnsOnCall[len(fake.execUpsertRevisionArgsForCall)]
	fake.execUpsertRevisionArgsForCall = append(fake.execUpsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecUpsertRevisionParams
	}{arg1, arg2})
	stub := fake.ExecUpsertRevisionStub
	fakeReturns := fake.execUpsertRevisionReturns
	fake.recordInvocation("ExecUpsertRevision", []interface{}{arg1, arg2})
	fake.execUpsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQuerier) ExecUpsertRevisionCallCount() int {
	fake.execUpsertRevisionMutex.RLock()
	defer fake.execUpsertRevisionMutex.RUnlock()
	return len(fake.execUpsertRevisionArgsForCall)
}

func (fake *FakeQuerier) ExecUpsertRevisionCalls(stub func(context.Context, *ent.ExecUpsertRevisionParams) error) {
	fake.execUpsertRevisionMutex.Lock()
	defer fake.execUpsertRevisionMutex.Unlock()
	fake.ExecUpsertRevisionStub = stub
}

func (fake *FakeQuerier) ExecUpsertRevisionArgsForCall(i int) (context.Context, *ent.ExecUpsertRevisionParams) {
	fake.execUpsertRevisionMutex.RLock()
	defer fake.execUpsertRevisionMutex.RUnlock()
	argsForCall := fake.execUpsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ExecUpsertRevisionReturns(result1 error) {
	fake.execUpsertRevisionMutex.Lock()
	defer fake.execUpsertRevisionMutex.Unlock()
	fake.ExecUpsertRevisionStub = nil
	fake.execUpsertRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) ExecUpsertRevisionReturnsOnCall(i int, result1 error) {
	fake.execUpsertRevisionMutex.Lock()
	defer fake.execUpsertRevisionMutex.Unlock()
	fake.ExecUpsertRevisionStub = nil
	if fake.execUpsertRevisionReturnsOnCall == nil {
		fake.execUpsertRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execUpsertRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuerier) GetJob(arg1 context.Context, arg2 *ent.GetJobParams) (*ent.Job, error) {
	fake.getJobMutex.Lock()
	ret, specificReturn := fake.getJobReturnsOnCall[len(fake.getJobArgsForCall)]
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.GetJobParams
	}{arg1, arg2})
	stub := fake.GetJobStub
	fakeReturns := fake.getJobReturns
	fake.recordInvocation("GetJob", []interface{}{arg1, arg2})
	fake.getJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakeQuerier) GetJobCalls(stub func(context.Context, *ent.GetJobParams) (*ent.Job, error)) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = stub
}

func (fake *FakeQuerier) GetJobArgsForCall(i int) (context.Context, *ent.GetJobParams) {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	argsForCall := fake.getJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) GetJobReturns(result1 *ent.Job, result2 error) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) GetJobReturnsOnCall(i int, result1 *ent.Job, result2 error) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = nil
	if fake.getJobReturnsOnCall == nil {
		fake.getJobReturnsOnCall = make(map[int]struct {
			result1 *ent.Job
			result2 error
		})
	}
	fake.getJobReturnsOnCall[i] = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) GetRevision(arg1 context.Context, arg2 *ent.GetRevisionParams) (*ent.Revision, error) {
	fake.getRevisionMutex.Lock()
	ret, specificReturn := fake.getRevisionReturnsOnCall[len(fake.getRevisionArgsForCall)]
	fake.getRevisionArgsForCall = append(fake.getRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}{arg1, arg2})
	stub := fake.GetRevisionStub
	fakeReturns := fake.getRevisionReturns
	fake.recordInvocation("GetRevision", []interface{}{arg1, arg2})
	fake.getRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) GetRevisionCallCount() int {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	return len(fake.getRevisionArgsForCall)
}

func (fake *FakeQuerier) GetRevisionCalls(stub func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = stub
}

func (fake *FakeQuerier) GetRevisionArgsForCall(i int) (context.Context, *ent.GetRevisionParams) {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	argsForCall := fake.getRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) GetRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	fake.getRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) GetRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	if fake.getRevisionReturnsOnCall == nil {
		fake.getRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.getRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) InsertJob(arg1 context.Context, arg2 *ent.InsertJobParams) (*ent.Job, error) {
	fake.insertJobMutex.Lock()
	ret, specificReturn := fake.insertJobReturnsOnCall[len(fake.insertJobArgsForCall)]
	fake.insertJobArgsForCall = append(fake.insertJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.InsertJobParams
	}{arg1, arg2})
	stub := fake.InsertJobStub
	fakeReturns := fake.insertJobReturns
	fake.recordInvocation("InsertJob", []interface{}{arg1, arg2})
	fake.insertJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) InsertJobCallCount() int {
	fake.insertJobMutex.RLock()
	defer fake.insertJobMutex.RUnlock()
	return len(fake.insertJobArgsForCall)
}

func (fake *FakeQuerier) InsertJobCalls(stub func(context.Context, *ent.InsertJobParams) (*ent.Job, error)) {
	fake.insertJobMutex.Lock()
	defer fake.insertJobMutex.Unlock()
	fake.InsertJobStub = stub
}

func (fake *FakeQuerier) InsertJobArgsForCall(i int) (context.Context, *ent.InsertJobParams) {
	fake.insertJobMutex.RLock()
	defer fake.insertJobMutex.RUnlock()
	argsForCall := fake.insertJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) InsertJobReturns(result1 *ent.Job, result2 error) {
	fake.insertJobMutex.Lock()
	defer fake.insertJobMutex.Unlock()
	fake.InsertJobStub = nil
	fake.insertJobReturns = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) InsertJobReturnsOnCall(i int, result1 *ent.Job, result2 error) {
	fake.insertJobMutex.Lock()
	defer fake.insertJobMutex.Unlock()
	fake.InsertJobStub = nil
	if fake.insertJobReturnsOnCall == nil {
		fake.insertJobReturnsOnCall = make(map[int]struct {
			result1 *ent.Job
			result2 error
		})
	}
	fake.insertJobReturnsOnCall[i] = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) InsertRevision(arg1 context.Context, arg2 *ent.InsertRevisionParams) (*ent.Revision, error) {
	fake.insertRevisionMutex.Lock()
	ret, specificReturn := fake.insertRevisionReturnsOnCall[len(fake.insertRevisionArgsForCall)]
	fake.insertRevisionArgsForCall = append(fake.insertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}{arg1, arg2})
	stub := fake.InsertRevisionStub
	fakeReturns := fake.insertRevisionReturns
	fake.recordInvocation("InsertRevision", []interface{}{arg1, arg2})
	fake.insertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) InsertRevisionCallCount() int {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	return len(fake.insertRevisionArgsForCall)
}

func (fake *FakeQuerier) InsertRevisionCalls(stub func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = stub
}

func (fake *FakeQuerier) InsertRevisionArgsForCall(i int) (context.Context, *ent.InsertRevisionParams) {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	argsForCall := fake.insertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) InsertRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	fake.insertRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) InsertRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	if fake.insertRevisionReturnsOnCall == nil {
		fake.insertRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.insertRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ListRevisions(arg1 context.Context, arg2 *ent.ListRevisionsParams) ([]*ent.Revision, error) {
	fake.listRevisionsMutex.Lock()
	ret, specificReturn := fake.listRevisionsReturnsOnCall[len(fake.listRevisionsArgsForCall)]
	fake.listRevisionsArgsForCall = append(fake.listRevisionsArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}{arg1, arg2})
	stub := fake.ListRevisionsStub
	fakeReturns := fake.listRevisionsReturns
	fake.recordInvocation("ListRevisions", []interface{}{arg1, arg2})
	fake.listRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) ListRevisionsCallCount() int {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	return len(fake.listRevisionsArgsForCall)
}

func (fake *FakeQuerier) ListRevisionsCalls(stub func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = stub
}

func (fake *FakeQuerier) ListRevisionsArgsForCall(i int) (context.Context, *ent.ListRevisionsParams) {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	argsForCall := fake.listRevisionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) ListRevisionsReturns(result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	fake.listRevisionsReturns = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) ListRevisionsReturnsOnCall(i int, result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	if fake.listRevisionsReturnsOnCall == nil {
		fake.listRevisionsReturnsOnCall = make(map[int]struct {
			result1 []*ent.Revision
			result2 error
		})
	}
	fake.listRevisionsReturnsOnCall[i] = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) UpdateRevision(arg1 context.Context, arg2 *ent.UpdateRevisionParams) (*ent.Revision, error) {
	fake.updateRevisionMutex.Lock()
	ret, specificReturn := fake.updateRevisionReturnsOnCall[len(fake.updateRevisionArgsForCall)]
	fake.updateRevisionArgsForCall = append(fake.updateRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.UpdateRevisionParams
	}{arg1, arg2})
	stub := fake.UpdateRevisionStub
	fakeReturns := fake.updateRevisionReturns
	fake.recordInvocation("UpdateRevision", []interface{}{arg1, arg2})
	fake.updateRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) UpdateRevisionCallCount() int {
	fake.updateRevisionMutex.RLock()
	defer fake.updateRevisionMutex.RUnlock()
	return len(fake.updateRevisionArgsForCall)
}

func (fake *FakeQuerier) UpdateRevisionCalls(stub func(context.Context, *ent.UpdateRevisionParams) (*ent.Revision, error)) {
	fake.updateRevisionMutex.Lock()
	defer fake.updateRevisionMutex.Unlock()
	fake.UpdateRevisionStub = stub
}

func (fake *FakeQuerier) UpdateRevisionArgsForCall(i int) (context.Context, *ent.UpdateRevisionParams) {
	fake.updateRevisionMutex.RLock()
	defer fake.updateRevisionMutex.RUnlock()
	argsForCall := fake.updateRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) UpdateRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.updateRevisionMutex.Lock()
	defer fake.updateRevisionMutex.Unlock()
	fake.UpdateRevisionStub = nil
	fake.updateRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) UpdateRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.updateRevisionMutex.Lock()
	defer fake.updateRevisionMutex.Unlock()
	fake.UpdateRevisionStub = nil
	if fake.updateRevisionReturnsOnCall == nil {
		fake.updateRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.updateRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) UpsertRevision(arg1 context.Context, arg2 *ent.UpsertRevisionParams) (*ent.Revision, error) {
	fake.upsertRevisionMutex.Lock()
	ret, specificReturn := fake.upsertRevisionReturnsOnCall[len(fake.upsertRevisionArgsForCall)]
	fake.upsertRevisionArgsForCall = append(fake.upsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.UpsertRevisionParams
	}{arg1, arg2})
	stub := fake.UpsertRevisionStub
	fakeReturns := fake.upsertRevisionReturns
	fake.recordInvocation("UpsertRevision", []interface{}{arg1, arg2})
	fake.upsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQuerier) UpsertRevisionCallCount() int {
	fake.upsertRevisionMutex.RLock()
	defer fake.upsertRevisionMutex.RUnlock()
	return len(fake.upsertRevisionArgsForCall)
}

func (fake *FakeQuerier) UpsertRevisionCalls(stub func(context.Context, *ent.UpsertRevisionParams) (*ent.Revision, error)) {
	fake.upsertRevisionMutex.Lock()
	defer fake.upsertRevisionMutex.Unlock()
	fake.UpsertRevisionStub = stub
}

func (fake *FakeQuerier) UpsertRevisionArgsForCall(i int) (context.Context, *ent.UpsertRevisionParams) {
	fake.upsertRevisionMutex.RLock()
	defer fake.upsertRevisionMutex.RUnlock()
	argsForCall := fake.upsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQuerier) UpsertRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.upsertRevisionMutex.Lock()
	defer fake.upsertRevisionMutex.Unlock()
	fake.UpsertRevisionStub = nil
	fake.upsertRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) UpsertRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.upsertRevisionMutex.Lock()
	defer fake.upsertRevisionMutex.Unlock()
	fake.UpsertRevisionStub = nil
	if fake.upsertRevisionReturnsOnCall == nil {
		fake.upsertRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.upsertRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeQuerier) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQuerier) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ent.Querier = new(FakeQuerier)
