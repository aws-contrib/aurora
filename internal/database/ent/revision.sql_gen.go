// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: revision.sql

package ent

import (
	"context"
	"time"
)

const createTableRevisions = `-- name: CreateTableRevisions :exec
CREATE TABLE IF NOT EXISTS aurora_schema_revisions (
    -- primary key column
    id TEXT PRIMARY KEY,
    -- aurora_schema_revisions name column
    description TEXT NOT NULL,
    -- execution timestamp column
    executed_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- execution time column
    execution_time BIGINT NOT NULL DEFAULT 0
)
`

// Creates a table named 'aurora_schema_revisions' with the following columns:
func (q *Queries) CreateTableRevisions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTableRevisions)
	return err
}

const execInsertRevision = `-- name: ExecInsertRevision :exec
INSERT INTO aurora_schema_revisions (
    id,
    description,
    executed_at,
    execution_time
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type ExecInsertRevisionParams struct {
	ID            string        `db:"id" json:"id"`
	Description   string        `db:"description" json:"description"`
	ExecutedAt    time.Time     `db:"executed_at" json:"executed_at"`
	ExecutionTime time.Duration `db:"execution_time" json:"execution_time"`
}

// Inserts a row into the table 'aurora_schema_revisions' with option ':exec'
func (q *Queries) ExecInsertRevision(ctx context.Context, arg *ExecInsertRevisionParams) error {
	_, err := q.db.Exec(ctx, execInsertRevision,
		arg.ID,
		arg.Description,
		arg.ExecutedAt,
		arg.ExecutionTime,
	)
	return err
}

const getRevision = `-- name: GetRevision :one
SELECT
    id,
    description,
    executed_at,
    execution_time
FROM
    aurora_schema_revisions
WHERE
    id = $1
`

type GetRevisionParams struct {
	ID string `db:"id" json:"id"`
}

// Retrieves a row from the table 'aurora_schema_revisions' with option ':one'
func (q *Queries) GetRevision(ctx context.Context, arg *GetRevisionParams) (*Revision, error) {
	row := q.db.QueryRow(ctx, getRevision, arg.ID)
	var i Revision
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.ExecutedAt,
		&i.ExecutionTime,
	)
	return &i, err
}

const insertRevision = `-- name: InsertRevision :one
INSERT INTO aurora_schema_revisions (
    id,
    description,
    executed_at,
    execution_time
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id, description, executed_at, execution_time
`

type InsertRevisionParams struct {
	ID            string        `db:"id" json:"id"`
	Description   string        `db:"description" json:"description"`
	ExecutedAt    time.Time     `db:"executed_at" json:"executed_at"`
	ExecutionTime time.Duration `db:"execution_time" json:"execution_time"`
}

// Inserts a row into the table 'aurora_schema_revisions' with option ':one'
func (q *Queries) InsertRevision(ctx context.Context, arg *InsertRevisionParams) (*Revision, error) {
	row := q.db.QueryRow(ctx, insertRevision,
		arg.ID,
		arg.Description,
		arg.ExecutedAt,
		arg.ExecutionTime,
	)
	var i Revision
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.ExecutedAt,
		&i.ExecutionTime,
	)
	return &i, err
}

const listRevisions = `-- name: ListRevisions :many
SELECT
    id,
    description,
    executed_at,
    execution_time
FROM
    aurora_schema_revisions
ORDER BY
    id
LIMIT
    $2::INT
    OFFSET
    $1::INT
`

type ListRevisionsParams struct {
	PageOffset *int32 `db:"page_offset" json:"page_offset"`
	PageLimit  *int32 `db:"page_limit" json:"page_limit"`
}

// Retrieves a list of rows from the table 'aurora_schema_revisions' with option ':many'
func (q *Queries) ListRevisions(ctx context.Context, arg *ListRevisionsParams) ([]*Revision, error) {
	rows, err := q.db.Query(ctx, listRevisions, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Revision{}
	for rows.Next() {
		var i Revision
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.ExecutedAt,
			&i.ExecutionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
